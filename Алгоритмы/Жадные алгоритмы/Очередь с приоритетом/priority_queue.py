# Первая строка входа содержит число операций 1 ≤ n ≤ 10**5. Каждая из последующих nn строк задают операцию одного из следующих двух типов: Insert, ExtractMax.
# Первая операция добавляет число x в очередь с приоритетами, вторая — извлекает максимальное число и выводит его.

import math #Подключаем библиотеку math для округления числа в нужную сторону
n=int(input()) #Вводим число операций
m=[] #Список операций
a=[] #Дерево
for i in range(n):
    m.append(input()) #Добавляем операцию в список

for i in range(len(m)): #Для каждой операции в списке
    if m[i]!='ExtractMax': #Если операция: не извлечение максимума
        a.append(int(m[i].split(' ')[1])) #Добавляем численный элемент в массив
        if len(a)==1: #Если длина массива = 1,
            continue # Тогда в просеивании элемента наверх нет смысла, и можно приступать к следующей операции
        else: #Если длина массива больше 1
            index1=len(a) #Задаём начальный индекс для просеивания вставленного элемента наверх
            while index1!=1: #Цикл продолжится до тех пор, пока элемент не поднимется на самый верх
                index2=math.floor(index1/2) #Вычисляем индекс родителя вставленного/просеянного элемента
                if a[index1-1] > a[index2-1]: #Если значение вставленного/просеянного элемента больше,чем у родителя
                    a[index1-1], a[index2-1] = a[index2-1], a[index1-1] #Элемент просеивается наверх
                    index1=index2 #Индекс просеиваемого элемента примет новое значение
                else: #Если значение вставленного/просеянного элемента меньше или равно значения родителя, тогда просеивать элемент наверх не имеет смысла и
                    break #Нужно закончить цикл просеивания
                    
    else: #Если операция: извлечение максимума
        index1=1 #Зададим индекс, в котором располагается максимальный элемент, поскольку это макс куча
        if len(a)>1: #Если длина массива больше 1
            a[index1-1], a[len(a)-1] = a[len(a)-1], a[index1-1] #Поменяем его местами с последним элементом кучи
        #В противном случае, длина будет равна 1, и мы можем сразу вывести элемент и удалить его
        print (a[len(a)-1]) #Выведем элемент
        del a[len(a)-1] #И удалим
        
        if len(a)>1: #У нас изменится длина дерева. Если она уменьшится до 0 или 1, тогда не будет необходимости в просеивании элемента и необходимо приступать к следующей операции. Если длина дерева уменьшится до числа от двух, тогда необходимо просеять корневой элемент вниз. Чтобы это сделать, нужно помнить, что у родителя может быть один или два ребенка. При одном ребенке, длина массива будет меньше максимального числа элементов в дереве. Таким образом, мы не сможем сравнить элементы 2*index1 и 2 * index1 + 1 за несуществованием последнего.
            while 2*index1<=len(a): #Пока у родителя существует ребенок
                if 2*index1==len(a): #Если ребенок единственный
                    if a[index1-1] < a[2*index1-1]: #Если значение родителя меньше, чем у ребенка
                        a[index1-1],a[2*index1-1] = a[2*index1-1],a[index1-1] #Меняем родителя и ребенка местами
                        index1 = 2*index1 #Фиксируем новый индекс просеиваемого элемента
                    else: break #Если значение родителя больше, значения ребенка, останавливаем цикл просеивания
                elif 2*index1<len(a): #Если ребенок не единственный
                    if a[index1-1]<a[2*index1-1] or a[index1-1]<a[2*index1]:
                        if a[2*index1-1] >= a[2*index1]: #Если Значение ребенка 1 больше значения ребенка 2
                            a[index1-1], a[2*index1-1] = a[2*index1-1], a[index1-1] #Меняем местами родителя и ребенка 1
                            index1 = 2*index1 #Фиксируем новый индекс просеиваемого элемента
                        else: #Если значение ребенка 2 больше значения ребенка 1
                            a[index1-1],a[2*index1] = a[2*index1], a[index1-1] # ребенок 2 просеивается наверх
                            index1 = 2*index1 + 1 #Фиксируем новый индекс просеиваемого элемента
                    else: break